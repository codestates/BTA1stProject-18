{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getErrorTypeFromErrorMessage = exports.formatError = exports.parseResultError = exports.parseRpcError = exports.ServerError = void 0;\nconst mustache_1 = __importDefault(require(\"mustache\"));\nconst rpc_error_schema_json_1 = __importDefault(require(\"../generated/rpc_error_schema.json\"));\nconst error_messages_json_1 = __importDefault(require(\"../res/error_messages.json\"));\nconst common_index_1 = require(\"../common-index\");\nconst errors_1 = require(\"../utils/errors\");\nconst mustacheHelpers = {\n  formatNear: () => (n, render) => common_index_1.utils.format.formatNearAmount(render(n))\n};\nclass ServerError extends errors_1.TypedError {}\nexports.ServerError = ServerError;\nclass ServerTransactionError extends ServerError {}\nfunction parseRpcError(errorObj) {\n  const result = {};\n  const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, '');\n  // NOTE: This assumes that all errors extend TypedError\n  const error = new ServerError(formatError(errorClassName, result), errorClassName);\n  Object.assign(error, result);\n  return error;\n}\nexports.parseRpcError = parseRpcError;\nfunction parseResultError(result) {\n  const server_error = parseRpcError(result.status.Failure);\n  const server_tx_error = new ServerTransactionError();\n  Object.assign(server_tx_error, server_error);\n  server_tx_error.type = server_error.type;\n  server_tx_error.message = server_error.message;\n  server_tx_error.transaction_outcome = result.transaction_outcome;\n  return server_tx_error;\n}\nexports.parseResultError = parseResultError;\nfunction formatError(errorClassName, errorData) {\n  if (typeof error_messages_json_1.default[errorClassName] === 'string') {\n    return mustache_1.default.render(error_messages_json_1.default[errorClassName], {\n      ...errorData,\n      ...mustacheHelpers\n    });\n  }\n  return JSON.stringify(errorData);\n}\nexports.formatError = formatError;\n/**\n * Walks through defined schema returning error(s) recursively\n * @param errorObj The error to be parsed\n * @param schema A defined schema in JSON mapping to the RPC errors\n * @param result An object used in recursion or called directly\n * @param typeName The human-readable error type name as defined in the JSON mapping\n */\nfunction walkSubtype(errorObj, schema, result, typeName) {\n  let error;\n  let type;\n  let errorTypeName;\n  for (const errorName in schema) {\n    if (isString(errorObj[errorName])) {\n      // Return early if error type is in a schema\n      return errorObj[errorName];\n    }\n    if (isObject(errorObj[errorName])) {\n      error = errorObj[errorName];\n      type = schema[errorName];\n      errorTypeName = errorName;\n    } else if (isObject(errorObj.kind) && isObject(errorObj.kind[errorName])) {\n      error = errorObj.kind[errorName];\n      type = schema[errorName];\n      errorTypeName = errorName;\n    } else {\n      continue;\n    }\n  }\n  if (error && type) {\n    for (const prop of Object.keys(type.props)) {\n      result[prop] = error[prop];\n    }\n    return walkSubtype(error, schema, result, errorTypeName);\n  } else {\n    // TODO: is this the right thing to do?\n    result.kind = errorObj;\n    return typeName;\n  }\n}\nfunction getErrorTypeFromErrorMessage(errorMessage) {\n  // This function should be removed when JSON RPC starts returning typed errors.\n  switch (true) {\n    case /^account .*? does not exist while viewing$/.test(errorMessage):\n      return 'AccountDoesNotExist';\n    case /^Account .*? doesn't exist$/.test(errorMessage):\n      return 'AccountDoesNotExist';\n    case /^access key .*? does not exist while viewing$/.test(errorMessage):\n      return 'AccessKeyDoesNotExist';\n    case /wasm execution failed with error: FunctionCallError\\(CompilationError\\(CodeDoesNotExist/.test(errorMessage):\n      return 'CodeDoesNotExist';\n    case /Transaction nonce \\d+ must be larger than nonce of the used access key \\d+/.test(errorMessage):\n      return 'InvalidNonce';\n    default:\n      return 'UntypedError';\n  }\n}\nexports.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;\n/**\n * Helper function determining if the argument is an object\n * @param n Value to check\n */\nfunction isObject(n) {\n  return Object.prototype.toString.call(n) === '[object Object]';\n}\n/**\n * Helper function determining if the argument is a string\n * @param n Value to check\n */\nfunction isString(n) {\n  return Object.prototype.toString.call(n) === '[object String]';\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","getErrorTypeFromErrorMessage","formatError","parseResultError","parseRpcError","ServerError","mustache_1","require","rpc_error_schema_json_1","error_messages_json_1","common_index_1","errors_1","mustacheHelpers","formatNear","n","render","utils","format","formatNearAmount","TypedError","ServerTransactionError","errorObj","result","errorClassName","walkSubtype","default","schema","error","assign","server_error","status","Failure","server_tx_error","type","message","transaction_outcome","errorData","JSON","stringify","typeName","errorTypeName","errorName","isString","isObject","kind","prop","keys","props","errorMessage","test","prototype","toString","call"],"sources":["/Users/dahan/Desktop/blockchain/BTA1stProject-18/near-pocket/node_modules/near-api-js/lib/utils/rpc_errors.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getErrorTypeFromErrorMessage = exports.formatError = exports.parseResultError = exports.parseRpcError = exports.ServerError = void 0;\nconst mustache_1 = __importDefault(require(\"mustache\"));\nconst rpc_error_schema_json_1 = __importDefault(require(\"../generated/rpc_error_schema.json\"));\nconst error_messages_json_1 = __importDefault(require(\"../res/error_messages.json\"));\nconst common_index_1 = require(\"../common-index\");\nconst errors_1 = require(\"../utils/errors\");\nconst mustacheHelpers = {\n    formatNear: () => (n, render) => common_index_1.utils.format.formatNearAmount(render(n))\n};\nclass ServerError extends errors_1.TypedError {\n}\nexports.ServerError = ServerError;\nclass ServerTransactionError extends ServerError {\n}\nfunction parseRpcError(errorObj) {\n    const result = {};\n    const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, '');\n    // NOTE: This assumes that all errors extend TypedError\n    const error = new ServerError(formatError(errorClassName, result), errorClassName);\n    Object.assign(error, result);\n    return error;\n}\nexports.parseRpcError = parseRpcError;\nfunction parseResultError(result) {\n    const server_error = parseRpcError(result.status.Failure);\n    const server_tx_error = new ServerTransactionError();\n    Object.assign(server_tx_error, server_error);\n    server_tx_error.type = server_error.type;\n    server_tx_error.message = server_error.message;\n    server_tx_error.transaction_outcome = result.transaction_outcome;\n    return server_tx_error;\n}\nexports.parseResultError = parseResultError;\nfunction formatError(errorClassName, errorData) {\n    if (typeof error_messages_json_1.default[errorClassName] === 'string') {\n        return mustache_1.default.render(error_messages_json_1.default[errorClassName], {\n            ...errorData,\n            ...mustacheHelpers\n        });\n    }\n    return JSON.stringify(errorData);\n}\nexports.formatError = formatError;\n/**\n * Walks through defined schema returning error(s) recursively\n * @param errorObj The error to be parsed\n * @param schema A defined schema in JSON mapping to the RPC errors\n * @param result An object used in recursion or called directly\n * @param typeName The human-readable error type name as defined in the JSON mapping\n */\nfunction walkSubtype(errorObj, schema, result, typeName) {\n    let error;\n    let type;\n    let errorTypeName;\n    for (const errorName in schema) {\n        if (isString(errorObj[errorName])) {\n            // Return early if error type is in a schema\n            return errorObj[errorName];\n        }\n        if (isObject(errorObj[errorName])) {\n            error = errorObj[errorName];\n            type = schema[errorName];\n            errorTypeName = errorName;\n        }\n        else if (isObject(errorObj.kind) && isObject(errorObj.kind[errorName])) {\n            error = errorObj.kind[errorName];\n            type = schema[errorName];\n            errorTypeName = errorName;\n        }\n        else {\n            continue;\n        }\n    }\n    if (error && type) {\n        for (const prop of Object.keys(type.props)) {\n            result[prop] = error[prop];\n        }\n        return walkSubtype(error, schema, result, errorTypeName);\n    }\n    else {\n        // TODO: is this the right thing to do?\n        result.kind = errorObj;\n        return typeName;\n    }\n}\nfunction getErrorTypeFromErrorMessage(errorMessage) {\n    // This function should be removed when JSON RPC starts returning typed errors.\n    switch (true) {\n        case /^account .*? does not exist while viewing$/.test(errorMessage):\n            return 'AccountDoesNotExist';\n        case /^Account .*? doesn't exist$/.test(errorMessage):\n            return 'AccountDoesNotExist';\n        case /^access key .*? does not exist while viewing$/.test(errorMessage):\n            return 'AccessKeyDoesNotExist';\n        case /wasm execution failed with error: FunctionCallError\\(CompilationError\\(CodeDoesNotExist/.test(errorMessage):\n            return 'CodeDoesNotExist';\n        case /Transaction nonce \\d+ must be larger than nonce of the used access key \\d+/.test(errorMessage):\n            return 'InvalidNonce';\n        default:\n            return 'UntypedError';\n    }\n}\nexports.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;\n/**\n * Helper function determining if the argument is an object\n * @param n Value to check\n */\nfunction isObject(n) {\n    return Object.prototype.toString.call(n) === '[object Object]';\n}\n/**\n * Helper function determining if the argument is a string\n * @param n Value to check\n */\nfunction isString(n) {\n    return Object.prototype.toString.call(n) === '[object String]';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}